
export import "std/vector.znn";
export import "vec2.znn";
import "std/math.znn";

export struct HistoryElem {
  vector<string> text;
  vec2 cursorBefore;
  vec2 cursorAfter;
};

export struct Buffer {
  vector<string> text;
  vector<string> origText;
  vector<HistoryElem> history;
  vector<HistoryElem> forward;
};

export Buffer(string content) {
  const lines = breakLines(move(content));
  return Buffer::Buffer(lines.copy(), lines.copy(),
      vector<HistoryElem>(),
      vector<HistoryElem>());
}

export bool isModified(Buffer* buffer) {
  return buffer^.text != buffer^.origText;
}

export vector<string> breakLines(string content) {
  mutable ret = {""}.as_vector();
  for (c : content)
    if (*c == '\n')
      ret.push_back("");
    else
      *ret.back() += *c;
  return move(ret);
}

export string joinLines(Buffer* buffer) {
  mutable ret = "";
  for (it : buffer->text) {
    if (it.index > 0)
      ret += '\n';
    ret += *it;
  }
  return move(ret);
}

export void changeIndent(Buffer mutable* buf, mutable vec2 start, mutable vec2 end, int amount) {
  if (end.y < start.y)
    swap(&start, &end);
  if (end.y > start.y && end.x == 0)
    --end.y;
  mutable tabs = "";
  for (i : range(0, abs(amount)))
    tabs += " ";
  if (amount > 0) {
    for (i : range(start.y, end.y + 1))
      buf^.text[i] = tabs + buf^.text[i];
  } else
    for (i : range(start.y, end.y + 1))
      if (buf^.text[i].substring(0, -amount) == tabs)
        buf^.text[i] = buf^.text[i].substring(-amount, buf^.text[i].size() + amount);
}


void addHistory(Buffer mutable* buf, vector<string> text, vec2 cursorBefore, vec2 cursorAfter) {
  buf->history.push_back(HistoryElem(move(text), cursorBefore, cursorAfter));
  buf->forward.clear();
}

export string getString(Buffer* buf, mutable vec2 startPos, mutable vec2 endPos) {
  if ((startPos.y == endPos.y && startPos.x > endPos.x) || startPos.y > endPos.y)
    swap(&startPos, &endPos);
  mutable ret = "";
  const origStartLine = startPos.y;
  while (startPos.y <= endPos.y) {
    if (!ret.empty())
      ret += "\n";
    const begin = startPos.y == origStartLine ? startPos.x : 0;
    ret += buf->text[startPos.y].substring(begin,
        (startPos.y == endPos.y ? endPos.x : buf->text[startPos.y].size()) - begin);
    ++startPos.y;
  }
  return move(ret);
}

export vec2 erase(Buffer mutable* buf, mutable vec2 startPos, mutable vec2 endPos) {
  if ((startPos.y == endPos.y && startPos.x > endPos.x) || startPos.y > endPos.y)
    swap(&startPos, &endPos);
  buf->addHistory(buf->text.copy(), endPos, startPos);
  buf->text[startPos.y] = buf->text[startPos.y].substring(0, startPos.x) +
      buf->text[endPos.y].substring(endPos.x, buf->text[endPos.y].size() - endPos.x);
  for (i : range(0, endPos.y - startPos.y))
    buf->text.remove(startPos.y + 1);
  return startPos;
}

export vec2? undo(Buffer mutable* buf, vec2 pos) {
  if (!buf->history.empty()) {
    const elem = buf->history.pop_back();
    buf->forward.push_back(HistoryElem(buf->text.copy(), elem.cursorBefore, elem.cursorAfter));
    buf->text = elem.text.copy();
    return elem.cursorBefore;
  }
  return null;
}

export vec2? redo(Buffer mutable* buf, vec2 pos) {
  if (!buf->forward.empty()) {
    const elem = buf->forward.pop_back();
    buf->history.push_back(HistoryElem(buf->text.copy(), elem.cursorBefore, elem.cursorAfter));
    buf->text = elem.text.copy();
    return elem.cursorAfter;
  }
  return null;
}

export vec2 onText(Buffer mutable* buf, string text, vec2 pos) {
  const newPos = pos + vec2(text.size(), 0);
  buf->addHistory(buf->text.copy(), pos, newPos);
  buf->text[pos.y] = buf->text[pos.y].insert(pos.x, text);
  return newPos;
}

export vec2 onEnter(Buffer mutable* buf, vec2 pos, bool withIndent) {
  buf->addHistory(buf->text.copy(), pos, vec2(0, pos.y + 1));
  assert(pos.y >= 0 && pos.y < buf->text.size());
  mutable indent = "";
  if (withIndent)
    for (i = 0; i < buf->text[pos.y].size() && buf->text[pos.y][i] == ' '; ++i)
      indent = indent + " ";
  buf->text.insert(pos.y + 1, indent);
  if (pos.x < buf->text[pos.y].size()) {
    buf->text[pos.y + 1] = buf->text[pos.y + 1] +
        buf->text[pos.y].substring(pos.x, buf->text[pos.y].size() - pos.x);
    buf->text[pos.y] = buf->text[pos.y].substring(0, pos.x);
  }
  return vec2(indent.size(), pos.y + 1);
}

export vec2 onBackspace(Buffer mutable* buf, mutable vec2 pos) {
  const textCopy = buf->text.copy();
  const oldPos = pos;
  if (pos.x > 0) {
    buf->text[pos.y] = buf->text[pos.y].substring(0, pos.x - 1)
        + buf->text[pos.y].substring(pos.x, buf->text[pos.y].size() - pos.x);
    --pos.x;
  } else if (pos.y > 0) {
    pos.x = buf->text[pos.y - 1].size();
    buf->text[pos.y - 1] += buf->text[pos.y];
    buf->text.remove(pos.y);
    --pos.y;
  }
  buf->addHistory(move(textCopy), oldPos, pos);
  return pos;
}

export vec2 onDelete(Buffer mutable* buf, vec2 pos) {
  buf->addHistory(buf->text.copy(), pos, pos);
  if (pos.x < buf->text[pos.y].size()) {
    buf->text[pos.y] = buf->text[pos.y].substring(0, pos.x)
      + buf->text[pos.y].substring(pos.x + 1, buf->text[pos.y].size() - pos.x - 1);
  } else if (pos.x < buf->text.size() - 1) {
    buf->text[pos.y] += buf->text[pos.y + 1];
    buf->text.remove(pos.y + 1);
  }
  return pos;
}

export vec2 onDeleteLine(Buffer mutable* buf, vec2 pos) {
  const newPos = pos.y == buf->text.size() - 1 ? pos - vec2(0, 1) : pos;
  buf->addHistory(buf->text.copy(), pos, newPos);
  buf->text.remove(pos.y);
  return newPos;
}
