export import "ui.znn";
import "std/vector.znn";
import "std/io.znn";
export import "buffer.znn";
import "std/char.znn";
import "std/time.znn";
export import "highlighter.znn";
export import "std/enum_map.znn";

export [@ui_element]
struct EditorUI {
  int fontSize;
  int tabWidth;
  color selectionColor;
  color selectionMirrorColor;
  color textColor;
  int mouseWheelStep;
  enum_map<TokenType, color> syntaxColors;
};

export struct ClickEvent {
  milliseconds_t time;
  vec2 cursor;
};

ClickEvent implicit_copy(ClickEvent*) = default;

export struct EditorUIState {
  bool mouseSelection;
  string? searchedText;
  int? searchedLine;
  ClickEvent lastLeftClick;
  ClickEvent previousLeftClick;
};

export struct EditorUIData {
  Buffer buffer;
  vec2 cursor;
  int scrollPos;
  vec2? selectionStart;
  Highlighter* highlighter;
};

vec2 getVisibleCursor(EditorUIData* data, Buffer* buffer) {
  mutable ret = data->cursor;
  ret.x = min(ret.x, data^.buffer.text[data->cursor.y].size());
  return move(ret);
}

export EditorUIState() {
  return EditorUIState::EditorUIState(false, null, null, ClickEvent(0, vec2(-1, -1)), ClickEvent(0, vec2(-1, -1)));
}

void renderSelection(EditorUI* editor, UIContext context, rectangle* r, vec2 textSize) {
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  if (!!data->selectionStart && *data->selectionStart != data->cursor) {
    mutable startPos = *data->selectionStart;
    mutable endPos = data->getVisibleCursor(&data->buffer);
    if ((startPos.y == endPos.y && startPos.x > endPos.x) || startPos.y > endPos.y)
      swap(&startPos, &endPos);
    const origStartLine = startPos.y;
    const renderLine = [&] (int line, int px, int kx) {
      const pos = r->v1 + vec2(px, (line - data->scrollPos)).pairwise_mult(textSize);
      const pos2 = r->v1 + vec2(kx, (line + 1 - data->scrollPos)).pairwise_mult(textSize);
      context.canvas->fillRectangle(&rectangle(pos, pos2), &editor->selectionColor);
    };
    while (startPos.y <= endPos.y) {
      renderLine(startPos.y, startPos.y == origStartLine ? startPos.x : 0,
          startPos.y == endPos.y ? endPos.x : data^.buffer.text[startPos.y].size());
      ++startPos.y;
    }
  }
}

void scrollToSearchedText(UIContext context, rectangle* r, vec2 textSize) {
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  const state = context.state^.get_state<EditorUIState>();
  if (state->searchedLine) {
    const line = min(max(0, *state->searchedLine - 1), data^.buffer.text.size() - 1);
    data^.cursor = vec2(0, line);
    if ((line - data->scrollPos) * textSize.y > r->height() || line < data->scrollPos)
      data->scrollPos = max(0, line - r->height() / (2 * textSize.y));
    state->searchedLine = null;
  } else
  if (state->searchedText) {
    for (lineIndex = 0; lineIndex < data^.buffer.text.size(); ++lineIndex) {
      const line = (lineIndex + data^.cursor.y) % data^.buffer.text.size();
      const beginPos = lineIndex == 0 ? data^.cursor.x + 1 : 0;
      if (const index = data^.buffer.text[line].find(beginPos, &*state->searchedText)) {
        data^.selectionStart = vec2(*index, line);
        data^.cursor = vec2(*index + state->searchedText^.size(), line);
        if ((line - data->scrollPos) * textSize.y > r->height() || line < data->scrollPos)
          data->scrollPos = max(0, line - r->height() / (2 * textSize.y));
        state->searchedText = null;
        break;
      }
    }
  }
}

export string? getSelectedTextInLine(EditorUIData* data) {
  if (!!data^.selectionStart && data^.cursor.y == data^.selectionStart^.y) {
    return data^.buffer.text[data^.cursor.y].substring(
        min(data^.selectionStart^.x, data^.cursor.x), abs(data^.selectionStart^.x - data^.cursor.x));
  }
  return null;
}

export void render(EditorUI* editor, UIContext context, rectangle* r) {
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  const textSize = context.canvas->getTextSize(" ", editor->fontSize);
  scrollToSearchedText(context, r, textSize);
  while (data^.scrollPos > 0 &&
      r^.v1.y + textSize.y * (data^.buffer.text.size() - data->scrollPos) < r^.v2.y)
    --data->scrollPos;
  renderSelection(editor, context, r, textSize);
  const selected = getSelectedTextInLine(data);
  mutable highlighterState = data^.highlighter^.getInitialState();
  for (line : range(data->scrollPos, data^.buffer.text.size())) {
    const pos = r->v1 + vec2(0, (line - data->scrollPos) * textSize.y);
    if (pos.y > r->v2.y)
      break;
    const lineStr = &data^.buffer.text[line];
    if (selected)
      for (ind = lineStr^.find(&*selected); !!ind; ind = lineStr^.find(*ind + 1, &*selected))
        if (line != data^.cursor.y || (*ind != data^.cursor.x && *ind != data^.selectionStart^.x)) {
          const spos = r->v1 + textSize.pairwise_mult(vec2(*ind, line) - vec2(0, data->scrollPos));
          context.canvas->fillRectangle(&rectangle(spos, spos + vec2(selected^.size() * textSize.x, textSize.y)),
              &editor->selectionMirrorColor);
        }
    const tokens = data^.highlighter^.getTokens(&highlighterState, *lineStr);
    mutable length = 0;
    for (token : tokens) {
      const content = token^.getContent();
      context.canvas->drawText(pos + vec2(length * textSize.x, 0), content,
          editor->fontSize, &editor^.syntaxColors[token^.getType()]);
      length += content.size();
    }
  }
  const cursorPos = r->v1 + textSize.pairwise_mult(data->getVisibleCursor(&data^.buffer) - vec2(0, data->scrollPos));
  context.canvas->drawLine(cursorPos, cursorPos + vec2(0, textSize.y), &editor->textColor);
}

export bool onKeyEvent(EditorUI* editor, UIContext context, rectangle* r, key_event* event) {
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  if (event^.type != key_event_type::DOWN)
    return false;
  const textSize = context.canvas->getTextSize(" ", editor->fontSize);
  const lctrl = event^.modifiers.contains(key_event_modifier::LCTRL);
  const lshift = event^.modifiers.contains(key_event_modifier::LSHIFT);
  if (event^.key == key_type::UP || event^.key == key_type::DOWN
      || event^.key == key_type::PAGE_UP || event^.key == key_type::PAGE_DOWN
      || event^.key == key_type::HOME || event^.key == key_type::END) {
    if (lshift) {
      if (!data->selectionStart)
        data->selectionStart = data->getVisibleCursor(&data^.buffer);
    } else
      data->selectionStart = null;
  }
  switch (event^.key) {
    case (ENTER) {
      data->cursor = data^.buffer.onEnter(data->getVisibleCursor(&data^.buffer), true);
    }
    case (BACKSPACE) {
      if (data->selectionStart) {
        data->cursor = data^.buffer.erase(*data->selectionStart, data->getVisibleCursor(&data^.buffer));
        data->selectionStart = null;
      } else
        data->cursor = data^.buffer.onBackspace(data->getVisibleCursor(&data^.buffer));
    }
    case (DELETE) {
      if (data->selectionStart) {
        data->cursor = data^.buffer.erase(*data->selectionStart, data->getVisibleCursor(&data^.buffer));
        data->selectionStart = null;
      } else {
        if (lctrl)
          data->cursor = data^.buffer.onDeleteLine(data->getVisibleCursor(&data^.buffer));
        else
          data->cursor = data^.buffer.onDelete(data->getVisibleCursor(&data^.buffer));
      }
    }
    case (HOME) {
      data->cursor.x = 0;
    }
    case (END) {
      data->cursor.x = data^.buffer.text[data->cursor.y].size();
    }
    case (UP) {
      data->cursor.y = max(0, data->cursor.y - 1);
    }
    case (DOWN) {
      data->cursor.y = min(data^.buffer.text.size() - 1, data->cursor.y + 1);
    }
    case (PAGE_UP) {
      data->cursor.y = max(0, data->cursor.y - r->height() / textSize.y);
    }
    case (PAGE_DOWN) {
      data->cursor.y = min(data^.buffer.text.size() - 1, data->cursor.y + r->height() / textSize.y);
    }
    case (TAB) {
      if (data->selectionStart) {
        data^.buffer.changeIndent(*data->selectionStart, data^.cursor,
            lshift ? -editor^.tabWidth : editor^.tabWidth);
      } else
      if (lshift) 
        data^.buffer.changeIndent(data^.cursor, data^.cursor, -editor^.tabWidth);
      else {
        mutable tabs = "";
        for (i : range(0, abs(editor^.tabWidth)))
          tabs += " ";
        discard editor->onTextEvent(context, r, tabs);
      }
    }
    case (LEFT) {
      if (lshift)
        if (!data->selectionStart)
          data->selectionStart = data->getVisibleCursor(&data^.buffer);
      const cursor = data->getVisibleCursor(&data^.buffer);
      if (!lshift && !!data^.selectionStart) {
        if (data^.selectionStart^.y < cursor.y ||
            (data^.selectionStart^.y == cursor.y && data^.selectionStart^.x < cursor.x))
          data^.cursor = *data^.selectionStart;
        data^.selectionStart = null;
      } else
      if (cursor.x == 0) {
        if (cursor.y > 0) {
          --data->cursor.y;
          data->cursor.x = data^.buffer.text[data->cursor.y].size();
        }
      } else {
        data->cursor.x = cursor.x - 1;
        if (lctrl) {
          const state = isalnum(data^.buffer.text[data^.cursor.y][data^.cursor.x]);
          while (data^.cursor.x > 0 && 
              isalnum(data^.buffer.text[data^.cursor.y][data^.cursor.x - 1]) == state)
            --data^.cursor.x;
        }
      }
    }
    case (RIGHT) {
      if (lshift)
        if (!data->selectionStart)
          data->selectionStart = data->getVisibleCursor(&data^.buffer);
      const cursor = data->getVisibleCursor(&data^.buffer);
      if (!lshift && !!data^.selectionStart) {
        if (data^.selectionStart^.y > cursor.y ||
            (data^.selectionStart^.y == cursor.y && data^.selectionStart^.x > cursor.x))
          data^.cursor = *data^.selectionStart;
        data^.selectionStart = null;
      } else
      if (data->cursor.x >= data^.buffer.text[data->cursor.y].size()) {
        if (data->cursor.y < data^.buffer.text.size() - 1) {
          ++data->cursor.y;
          data->cursor.x = 0;
        }
      } else {
        ++data->cursor.x;
        if (lctrl) {
          const state = isalnum(data^.buffer.text[data^.cursor.y][data^.cursor.x - 1]);
          while (data^.cursor.x < data^.buffer.text[data^.cursor.y].size() && 
              isalnum(data^.buffer.text[data^.cursor.y][data^.cursor.x]) == state)
            ++data^.cursor.x;
        }
      }
    }
    case (C) {
      if (lctrl && !!data->selectionStart) {
        context.canvas->setClipboard(data^.buffer.getString(*data->selectionStart, data->getVisibleCursor(&data^.buffer)));
      } else
      return false;
    }
    case (X) {
      if (lctrl && !!data->selectionStart) {
        context.canvas->setClipboard(data^.buffer.getString(*data->selectionStart, data->getVisibleCursor(&data^.buffer)));
        data->cursor = data^.buffer.erase(*data->selectionStart, data->getVisibleCursor(&data^.buffer));
        data^.selectionStart = null;
      } else
        return false;
    }
    case (V) {
      if (lctrl) {
        const lines = breakLines(context.canvas->getClipboard());
        for (it : lines) {
          discard editor->onTextEvent(context, r, *it);
          if (it.index < lines.size() - 1)
            data->cursor = data^.buffer.onEnter(data->getVisibleCursor(&data^.buffer), false);
        }
      } else
        return false;
    }
    case (Z) {
      if (lctrl) {
        if (const pos = data^.buffer.undo(data->getVisibleCursor(&data^.buffer)))
          data->cursor = *pos;
      } else
        return false;
    }
    case (Y) {
      if (lctrl) {
        if (const pos = data^.buffer.redo(data->getVisibleCursor(&data^.buffer)))
          data->cursor = *pos;
      } else
        return false;
    }
    default {
      return false;
    }
  }
  while (true) {
    const cursorPos = r->v1.y + textSize.y * (data->getVisibleCursor(&data^.buffer).y - data->scrollPos);
    if (data->scrollPos > 0 && cursorPos < r->v1.y + 20)
      --data->scrollPos;
    else if (cursorPos > r->v2.y - textSize.y)
      ++data->scrollPos;
    else
      break;
  }
  return true;
}

export bool onMouseEvent(EditorUI* editor, UIContext context, rectangle* r, mouse_event* event) {
  const state = context.state^.get_state<EditorUIState>();
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  switch (event->type) {
    case (MOUSE_MOVEMENT) {
      if (state->mouseSelection) {
        const textSize = context.canvas->getTextSize(" ", editor->fontSize);
        data->cursor = (event->pos - r->v1).pairwise_div(textSize) + vec2(0, data->scrollPos);
        data->cursor.y = min(data->buffer.text.size() - 1, data->cursor.y);
        data->cursor.x = min(data->buffer.text[data->cursor.y].size(), data->cursor.x);
      }
      return true;
    }
    case (LEFT_RELEASED) {
      if (state->mouseSelection) {
        if (data->selectionStart == data->cursor)
          data->selectionStart = null;
        state->mouseSelection = false;
        return true;
      }
    }
    case (LEFT) {
      const textSize = context.canvas->getTextSize(" ", editor->fontSize);
      const curTime = current_time_milli();
      const clickPos = (event->pos - r->v1).pairwise_div(textSize) + vec2(0, data->scrollPos);
      data->cursor.y = min(data->buffer.text.size() - 1, clickPos.y);
      data->cursor.x = min(data->buffer.text[data->cursor.y].size(), clickPos.x);
      if (curTime - state->previousLeftClick.time < 500 && clickPos == state->previousLeftClick.cursor) {
        data->selectionStart = vec2(0, data->cursor.y);
        if (data->cursor.y < data->buffer.text.size() - 1)
          data->cursor = vec2(0, data->cursor.y + 1);
        else
          data->cursor = vec2(data->buffer.text[data->cursor.y].size(), data->cursor.y);
      } else
      if (clickPos == data^.cursor && curTime - state->lastLeftClick.time < 500 &&
          clickPos == state->lastLeftClick.cursor) {
        const status = isalnum(data->buffer.text[data->cursor.y][data->cursor.x]);
        mutable start = data->cursor;
        while (start.x > 0 && isalnum(data->buffer.text[start.y][start.x - 1]) == status)
          --start.x;
        mutable end = data->cursor;
        while (end.x < data->buffer.text[end.y].size() -1 &&
          isalnum(data->buffer.text[end.y][end.x]) == status)
          ++end.x;
        data->selectionStart = start;
        data->cursor = end;
      } else {
        data->selectionStart = data->cursor;
        state->mouseSelection = true;
      }
      state->previousLeftClick = state->lastLeftClick;
      state->lastLeftClick = ClickEvent(curTime, clickPos);
      return true;
    }
    case (WHEEL_UP) {
      data->scrollPos = max(0, data->scrollPos - editor->mouseWheelStep);
    }
    case (WHEEL_DOWN) {
      data->scrollPos += editor->mouseWheelStep;
    }
    default {
      return false;
    }
  }
  return true;
}

export bool onTextEvent(EditorUI*, UIContext context, rectangle*, string text) {
  const data = **context.data^.cast_to<EditorUIData mutable*>();
  if (data->selectionStart) {
    data->cursor = data^.buffer.erase(*data->selectionStart, data->getVisibleCursor(&data^.buffer));
    data->selectionStart = null;
  }
  data->cursor = data^.buffer.onText(text, data->getVisibleCursor(&data^.buffer));
  return true;
}

export void destruct(EditorUI*) {
}

