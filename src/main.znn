import "sdl.znn";
import "sdl_surface.znn";
import "sdl_canvas.znn";
import "ui.znn";
import "std/io.znn";
import "ui_reader.znn";
import "sdl_ttf.znn";
import "ui_data.znn";
import "std/enum_set.znn";
import "std/enum.znn";
import "std/time.znn";
import "std/flags.znn";
import "std/panic.znn";
import "pretty_input.znn";
import "editor_ui.znn";
import "std/vector.znn";
import "sdl_event.znn";
import "scrollbar_ui.znn";
import "dialogs.znn";
import "highlighter.znn";

box<UIElement>!string readUIFrom(string path) {
  const content = *open_file_r(path)^.read_content();
  mutable stream = try create_input_stream(content);
  stream.add_concept_mapping<UIElement, EditorUI>("editor");
  stream.add_concept_mapping<UIElement, ScrollbarUI>("scrollbar");
  stream.register_ui_elems();
  return stream.read_data<box<UIElement>>();
}

export bool round_brackets(pretty_dummy_struct<EditorUI>) {
  return true;
}

export bool round_brackets(pretty_dummy_struct<ScrollbarUI>) {
  return true;
}

struct Flags {
  bool noPanicHandler;
  string? font;
  vector<string> all;
};

template <Types...> requires copy<Types>...
UIRecord createRecord(string[] names, Types... values) {
  mutable ret = UIRecord();
  static for (i = 0; i < countof(values); ++i) {
    ret.insert(names[i], values...[i].copy().box_as<any>());
  }
  return move(ret);
}

void setPrompt(UIRecord mutable* uiData, string question, box<invoke<void>> callback_yes,
    box<invoke<void>> callback_no) {
  uiData->insert("prompt_callback_yes", [move(callback_yes), uiData] {
    callback_yes^();
    uiData->erase(&"prompt_callback_yes");
    uiData->erase(&"prompt_callback_no");
    uiData->erase(&"prompt_text");
  }.box_as<UICallback>().box_as<any>());
  uiData->insert("prompt_callback_no", [move(callback_no), uiData] {
    callback_no^();
    uiData->erase(&"prompt_callback_yes");
    uiData->erase(&"prompt_callback_no");
    uiData->erase(&"prompt_text");
  }.box_as<UICallback>().box_as<any>());
  uiData->insert("prompt_text", question.box_as<any>());
}

bool isContentUpdated(vector<EditorUIData>* data) {
  for (elem : *data)
    if (elem^.buffer.isModified())
      return false;
  return true;
}

template <T>
struct SearchInfo {
  int scrollPos;
  int pos;
  string entry;
  vector<T> results;
};

template <T> requires copy<T>
SearchInfo<T> copy(SearchInfo<T>*) = default;

template <T>
void scrollUp(SearchInfo<T> mutable* info, int height) {
  if (info^.pos > 0) {
    --info^.pos;
    if (info^.pos - info^.scrollPos < 2 && info^.scrollPos > 0)
      --info^.scrollPos;
  } else {
    info^.pos = info^.results.size() - 1;
    info^.scrollPos = max(0, info^.pos - height + 1);
  }
}

template <T>
void scrollDown(SearchInfo<T> mutable* info, int height) {
  if (info^.pos < info^.results.size() - 1) {
    ++info^.pos;
    if (info^.pos - info^.scrollPos > height - 3 &&
        info^.scrollPos < info^.results.size() - height)
      ++info^.scrollPos;
  } else {
    info^.pos = 0;
    info^.scrollPos = 0;
  }
}

template <T>
void handleTextEntry(SearchInfo<T> mutable* info, TextCallbackParam param) {
  switch (param) {
    case (text) {
      info^.entry += text;
    }
    case (backspace) {
      if (!info^.entry.empty())
        info^.entry = info^.entry.substring(0, info^.entry.size() - 1);
    }
  }
}
union FileSearchResult {
  string path;
  int line;
};

FileSearchResult copy(FileSearchResult*) = default;

struct LocationResult {
  string text;
  int line;
  int bufferIndex;
};

LocationResult copy(LocationResult*) = default;

union OverlayInfo {
  string search;
  SearchInfo<FileSearchResult> file;
  SearchInfo<LocationResult> location;
};

struct NextBufferInfo {
  int index;
  int scrollPos;
};

struct AllState {
  SDLCanvas canvas;
  rectangle uiBounds;
  bool exit;
  UIRecord uiData;
  bool flushEvents;
  SDLEventsState eventsState;
  UIState uiState;
  int currentBuffer;
  NextBufferInfo? nextBuffer;
  vector<EditorUIData> editorData;
  vector<int> bufferOrder;
  vector<string> paths;
  string? lastSearchedText;
  OverlayInfo? overlayInfo;
  SearchInfo<LocationResult>? previousLocationSearch;
  vector<box<invoke<void>>> toDo;
  Highlighter highlighter;
};

AllState(SDLCanvas canvas, rectangle windowBounds, vector<string> paths, Highlighter highlighter) {
  return AllState::AllState(
    .canvas = move(canvas),
    .uiBounds = move(windowBounds),
    .exit = false,
    .uiData = UIRecord(),
    .flushEvents = false,
    .eventsState = SDLEventsState(),
    .uiState = UIState(),
    .currentBuffer = 0,
    .nextBuffer = null,
    .editorData = vector<EditorUIData>(),
    .bufferOrder = vector<int>(),
    .paths = move(paths),
    .lastSearchedText = null,
    .overlayInfo = null,
    .previousLocationSearch = null,
    .toDo = vector<box<invoke<void>>>(),
    .highlighter = move(highlighter)
  );
}

void addCursorHistory(AllState mutable* allState) {
  const editorData = allState^.getEditorData();
  allState^.getEditorState()^.addCursorHistory(editorData^.cursor, editorData^.buffer.path);
}

EditorUIData mutable* getEditorData(AllState mutable* allState) {
  return &allState^.editorData[allState^.currentBuffer];
}

EditorUIState mutable* getEditorState(AllState mutable* allState) {
  return allState^.uiState.get_state<EditorUIState>();
}

void switchBufferDownCallback(AllState mutable* allState) {
  if (!allState^.nextBuffer)
    allState^.nextBuffer = NextBufferInfo(1, 0);
  else if (allState^.nextBuffer^.index < allState^.paths.size() - 1) {
    ++allState^.nextBuffer^.index;
    if (allState^.nextBuffer^.index - allState^.nextBuffer^.scrollPos > 17 && 
        allState^.nextBuffer^.scrollPos < allState^.paths.size() - 20)
      ++allState^.nextBuffer^.scrollPos;
  } else {
    allState^.nextBuffer^.index = 0;
    allState^.nextBuffer^.scrollPos = 0;
  }
}

void switchBufferUpCallback(AllState mutable* allState) {
  if (allState^.nextBuffer^.index > 0) {
    --allState^.nextBuffer^.index;
    if (allState^.nextBuffer^.index - allState^.nextBuffer^.scrollPos < 2 && allState^.nextBuffer^.scrollPos > 0)
      --allState^.nextBuffer^.scrollPos;
  } else {
    allState^.nextBuffer^.index = allState^.paths.size() - 1;
    allState^.nextBuffer^.scrollPos = max(0, allState^.paths.size() - 20);
  }
}

void addPermanentCallbacks(AllState mutable* allState) {
  allState^.uiData.insert("exit_callback", [allState] {
    if (allState^.overlayInfo) {
      allState^.overlayInfo = null;
      return;
    } else
      setPrompt(&allState^.uiData, "Exit?",
          [allState] { allState^.exit = true; }.box_as<invoke<void>>(),
          [allState] {
            allState^.flushEvents = true;
            discard allState^.eventsState.getEvents();
          }.box_as<invoke<void>>()
      );
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("open_file_callback", [allState] {
    allState^.toDo.push_back([allState] {
      for (file : getOpenFiles("Open file(s):")) {
        if (!allState^.paths.find(&*file)) {
          allState^.paths.push_back(*file);
          allState^.bufferOrder.insert(0, allState^.paths.size() - 1);
          allState^.editorData.push_back(EditorUIData(
            Buffer(*file, *open_file_r(*file)^.read_content()),
            vec2(0, 0),
            vec2(0, 0),
            null,
            &allState^.highlighter
          ));
          allState^.currentBuffer = allState^.editorData.size() - 1;
        }
      }
    }.box_as<invoke<void>>());
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("switch_buffer_callback1", [allState] {
    switchBufferDownCallback(allState);
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("save_callback", [allState] {
    for (elem : allState^.editorData)
      if (elem^.buffer.isModified())
        if (const file = open_file_w(allState^.paths[elem.index])) {
          file->printf(elem->buffer.joinLines());
          elem->buffer.origText = elem->buffer.text.copy();
        }
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("search_callback", [allState] {
    allState^.overlayInfo = OverlayInfo::search("");
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("file_search_callback", [allState] {
    allState^.overlayInfo = OverlayInfo::file(SearchInfo(0, 0, "", vector<FileSearchResult>()));
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("location_search_callback", [allState] {
    if (const text = getSelectedTextInLine(allState^.getEditorData()))
      allState^.doLocationSearch(*text);
    else if (!allState^.overlayInfo && !!allState^.previousLocationSearch)
      allState^.overlayInfo = OverlayInfo::location(allState^.previousLocationSearch^.copy());
    else 
      allState^.doLocationSearch("");
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("search_repeat_callback", [allState] {
    const state = allState^.uiState.get_state<EditorUIState>();
    const editorData = allState^.getEditorData();
    if (const text = getSelectedTextInLine(editorData)) {
      allState^.addCursorHistory();
      state^.searchedText = *text;
      allState^.lastSearchedText = *text;
    } else
    if (allState^.lastSearchedText) {
      allState^.addCursorHistory();
      state^.searchedText = *allState^.lastSearchedText;
    }
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("navigate_back_callback", [allState] {
    allState^.toDo.push_back([allState] {
      const state = allState^.getEditorState();
      if (!state^.cursorHistory.empty()) {
        const data = allState^.getEditorData();
        data^.selectionStart = null;
        state^.addCursorForward(data^.cursor, data^.buffer.path);
        const popped = state^.cursorHistory.pop_back();
        allState^.currentBuffer = *allState^.paths.find(&popped.path);
        state^.searchedPos = popped.pos;
      }
    }.box_as<invoke<void>>());
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("navigate_forward_callback", [allState] {
    allState^.toDo.push_back([allState] {
      const state = allState^.getEditorState();
      if (!state^.cursorForward.empty()) {
        const data = allState^.getEditorData();
        data^.selectionStart = null;
        const popped = state^.cursorForward.pop_back();
        allState^.currentBuffer = *allState^.paths.find(&popped.path);
        state^.searchedPos = popped.pos;
        state^.cursorHistory.push_back(CursorData(data^.cursor, data^.buffer.path));
      }
    }.box_as<invoke<void>>());
  }.box_as<UICallback>().box_as<any>());
  allState^.uiData.insert("switch_to_header_callback", [allState] {
    const curPath = allState^.getEditorData()^.buffer.path;
    const suffix1 = ".cpp";
    const suffix2 = ".h";
    const toPath = [&] -> string? {
      if (curPath.suffix(suffix1.size()) == suffix1)
        return curPath.prefix(curPath.size() - suffix1.size()) + suffix2;
      if (curPath.suffix(suffix2.size()) == suffix2)
        return curPath.prefix(curPath.size() - suffix2.size()) + suffix1;
      return null;
    }();
    if (toPath)
      if (const ind = allState^.paths.find(&*toPath)) {
        allState^.addCursorHistory();
        allState^.switchToBuffer(*ind);
      }
  }.box_as<UICallback>().box_as<any>());
}

void doLocationSearch(AllState mutable* allState, string text) {
  mutable locationResults = vector<LocationResult>();
  if (text.size() > 1)
    for (elem : allState^.editorData) {
      for (line : elem^.buffer.text)
        if (!!line^.find(&text)) {
          locationResults.push_back(LocationResult(
            .text = *line,
            .line = line.index + 1,
            .bufferIndex = elem.index
          ));
          if (locationResults.size() > 100)
            break;
        }
    }
  allState^.previousLocationSearch = SearchInfo(0, 0, text, move(locationResults));
  allState^.overlayInfo = OverlayInfo::location(allState^.previousLocationSearch^.copy());
}

void doFileSearch(AllState mutable* allState, string text) {
  mutable fileResults = vector<FileSearchResult>();
  if (text.size() > 1)
    for (elem : allState^.paths)
      if (!!elem^.find(&text)) {
        fileResults.push_back(FileSearchResult::path(*elem));
        if (fileResults.size() > 100)
          break;
      }
  if (const n = text.to_int())
    fileResults.push_back(FileSearchResult::line(*n));
  allState^.overlayInfo = OverlayInfo::file(SearchInfo(0, 0, text, move(fileResults)));
}

void searchAndReplace(AllState mutable* allState, string pattern, string replace) {
  const data = allState^.getEditorData();
  data^.buffer.addHistory(data^.cursor, data^.cursor);
  for (line : data^.buffer.text)
    *line = line^.replace(&pattern, &replace);
}

pair<string, string>? breakIntoPatternAndReplace(string text) {
  for (i : range(0, text.size())) {
    if (text[i] == '\\') {
      ++i;
      continue;
    }
    if (text[i] == '/')
      return pair(text.substring(0, i), text.substring(i + 1, text.size() - i - 1));
  }
  return null;
}

void addOverlayCallbacks(AllState mutable* allState) {
  allState^.uiData.erase(&"location_results_up");
  allState^.uiData.erase(&"location_results_down");
  allState^.uiData.erase(&"location_results_confirm");
  allState^.uiData.erase(&"search_entry");
  allState^.uiData.erase(&"search_confirm");
  allState^.uiData.erase(&"search_content");
  allState^.uiData.erase(&"search_paste_callback");
  allState^.uiData.erase(&"location_results");
  allState^.uiData.erase(&"file_results");
  if (allState^.overlayInfo)
    switch (*allState^.overlayInfo) {
      case (search) {
        allState^.uiData.insert("search_paste_callback", [allState, &search] {
          search = search + allState^.canvas.getClipboard();
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("search_confirm", [allState, &search]() {
          allState^.addCursorHistory();
          if (const p = breakIntoPatternAndReplace(search))
            allState^.searchAndReplace(p^.first, p^.second);
          else {
            allState^.lastSearchedText = search;
            allState^.getEditorState()->searchedText = search;
          }
          allState^.overlayInfo = null;
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("search_entry", [allState, &search](TextCallbackParam param) {
          switch (param) {
            case (text) {
              search += text;
            }
            case (backspace) {
              if (!search.empty())
                search = search.substring(0, search.size() - 1);
            }
          }
        }.box_as<UITextCallback>().box_as<any>());
        allState^.uiData.insert("search_content", box_as<any>(search));
      }
      case (file) {
        allState^.uiData.insert("search_entry", [allState, &file](TextCallbackParam param) {
          file.handleTextEntry(move(param));
          allState^.doFileSearch(file.entry);
        }.box_as<UITextCallback>().box_as<any>());
        allState^.uiData.insert("search_content", box_as<any>(file.entry));
        mutable v = vector<box<any>>();
        for (i : range(file.scrollPos, min(file.results.size(), file.scrollPos + 20))) {
          mutable r = UIRecord();
          switch (file.results[i]) {
            case (path) { r.insert("text", path.box_as<any>()); }
            case (line) { r.insert("text", "Line: {line}".box_as<any>()); }
          }
          if (i == file.pos)
            r.insert("selected", 1.box_as<any>());
          v.push_back(move(r).box_as<any>());
        }
        allState^.uiData.insert("file_results", move(v).box_as<any>());
        allState^.uiData.insert("location_results_up", [allState, &file] {
          file.scrollUp(20);
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("location_results_down", [allState, &file] {
          file.scrollDown(20);
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("location_results_confirm", [allState, &file] {
          if (!file.results.empty())
            allState^.toDo.push_back([allState, &file] {
              allState^.addCursorHistory();
              switch (file.results[file.pos]) {
                case (path) {
                  allState^.switchToBuffer(*allState^.paths.find(&path));
                }
                case (line) {
                  allState^.getEditorState()->searchedPos = vec2(0, line - 1);
                }
              }
              allState^.overlayInfo = null;
            }.box_as<invoke<void>>());
        }.box_as<UICallback>().box_as<any>());        
      }
      case (location) {
        allState^.uiData.insert("search_entry", [allState, &location](TextCallbackParam param) {
          location.handleTextEntry(move(param));
          allState^.doLocationSearch(location.entry);
        }.box_as<UITextCallback>().box_as<any>());
        allState^.uiData.insert("search_content", box_as<any>(location.entry));
        mutable v = vector<box<any>>();
        for (i : range(location.scrollPos,
            min(location.results.size(), location.scrollPos + 20))) {
          const elem = &location.results[i];
          mutable r = UIRecord();
          r.insert("text", elem^.text.box_as<any>());
          r.insert("path", allState^.paths[elem^.bufferIndex].box_as<any>());
          r.insert("line", elem^.line.to_string().box_as<any>());
          if (i == location.pos)
            r.insert("selected", 1.box_as<any>());
          v.push_back(move(r).box_as<any>());
        }
        allState^.uiData.insert("location_results", move(v).box_as<any>());
        allState^.uiData.insert("location_results_up", [allState, &location] {
          location.scrollUp(10);
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("location_results_down", [allState, &location] {
          location.scrollDown(10);
        }.box_as<UICallback>().box_as<any>());
        allState^.uiData.insert("location_results_confirm", [allState, &location] {
          if (!location.results.empty())
            allState^.toDo.push_back([allState, &location] {
              allState^.addCursorHistory();
              const result = &location.results[location.pos];
              allState^.switchToBuffer(result->bufferIndex);
              allState^.getEditorData()^.selectionStart = null;
              allState^.getEditorState()^.searchedPos = vec2(0, result^.line - 1);
            }.box_as<invoke<void>>());
        }.box_as<UICallback>().box_as<any>());        
      }
    }
}

void switchToBuffer(AllState mutable* allState, int index) {
  allState^.currentBuffer = index;
  allState^.bufferOrder.remove(*allState^.bufferOrder.find(&index));
  allState^.bufferOrder.insert(0, index);
}

void addConditionalCallbacks(AllState mutable* allState) {
  allState^.addOverlayCallbacks();
  if (allState^.nextBuffer) {
    mutable v = vector<box<any>>();
    for (i : range(allState^.nextBuffer^.scrollPos,
        min(allState^.paths.size(), allState^.nextBuffer^.scrollPos + 20))) {
      mutable r = UIRecord();
      r.insert("text", allState^.paths[allState^.bufferOrder[i]].box_as<any>());
      if (i == allState^.nextBuffer^.index)
        r.insert("selected", 1.box_as<any>());
      v.push_back(move(r).box_as<any>());
    }
    allState^.uiData.insert("next_buffer_path", move(v).box_as<any>());
    allState^.uiData.insert("switch_buffer_callback2", [allState] {
      allState^.addCursorHistory();
      allState^.switchToBuffer(allState^.bufferOrder[allState^.nextBuffer^.index]);
      allState^.nextBuffer = null;
    }.box_as<UICallback>().box_as<any>());
    allState^.uiData.insert("switch_buffer_callback_up", [allState] {
      switchBufferUpCallback(allState);
    }.box_as<UICallback>().box_as<any>());
    allState^.uiData.insert("switch_buffer_callback_down", [allState] {
      switchBufferDownCallback(allState);
    }.box_as<UICallback>().box_as<any>());
  } else {
    allState^.uiData.erase(&"switch_buffer_callback_up");
    allState^.uiData.erase(&"switch_buffer_callback_down");
    allState^.uiData.erase(&"switch_buffer_callback2");
    allState^.uiData.erase(&"next_buffer_path");
  }
  if (isContentUpdated(&allState^.editorData))
    allState^.uiData.insert("no_changes", 1.box_as<any>());
  else
    allState^.uiData.erase(&"no_changes");
  allState^.uiData.insert("editor", box_as<any>(allState^.getEditorData()));
  allState^.uiData.insert("buffer_name", (allState^.paths[allState^.currentBuffer] +
      " {allState^.getEditorData()^.cursor + vec2(1, 1)}").box_as<any>());
}

int main(string[] args) {
  const flags = *read_flags<Flags>(args);
  const panic_handler = [](string s) { printf("{s}\n"); exit(0); };
  if (!flags.noPanicHandler)
    set_panic_handler(&panic_handler);
  *sdl_init();
  const dataDir = sdl_data_directory_path();
  mutable ui = *readUIFrom(dataDir + "ui.txt");
  const window = *sdl_create_window(vec2(1280, 720), "ZIM", true);
  mutable font = *window.loadSDLFont(flags.font ?? dataDir + "font.ttf", 10, 100);
  const getCanvas = [&] {
    const textTexture = *window.make_target_texture(vec2(100, 100));
    const gameSprites = hash_map<string, sdl_texture>();
    return SDLCanvas(&window, &font, move(gameSprites), move(textTexture));
  };
  mutable allState = AllState(
      getCanvas(),
      rectangle(vec2(0, 0), window.size()),
      flags.all.transform([](string* path) { return get_canonical_path(*path); }),
      Highlighter("/usr/share/source-highlight/", "zenon.lang")
  );
  for (path : allState.paths) {
    allState.bufferOrder.push_back(path.index);
    allState.editorData.push_back(EditorUIData(
      Buffer(*path, *open_file_r(*path)^.read_content()),
      vec2(0, 0),
      vec2(0, 0),
      null,
      &allState.highlighter
    ));
  }
  allState.addPermanentCallbacks();
  while (!allState.exit) {
    while (!allState.toDo.empty()) {
      allState.toDo.back()^^();
      discard allState.toDo.pop_back();
    }
    allState.addConditionalCallbacks();
    const context = UIContext(&allState.canvas, &allState.uiData, &allState.uiState, 0.1);
    for (event : allState.eventsState.getEvents()) {
      if (allState.exit || allState.flushEvents) {
        allState.flushEvents = false;
        break;
      }
      switch (*event) {
        case (windowResized) {
          allState.uiBounds = rectangle(vec2(0, 0), windowResized);
        }
        case (quit) { return 0; }
        case (key) {
          if (key.key == key_type::F1 && key.type == key_event_type::DOWN) {
            allState.canvas = getCanvas();
            if (const res = readUIFrom(dataDir + "ui.txt"))
              ui = *move(res);
            else
              printf(res.get_error());
            } else
            discard ui^.onKeyEvent(context, &allState.uiBounds, &key);
        }
        case (mouse) {
          discard ui^.onMouseEvent(context, &allState.uiBounds, &mouse);
        }
        case (text) {
          discard ui^.onTextEvent(context, &allState.uiBounds, text);
        }
        default {}
      }
    }
    ui^.render(context, &allState.uiBounds);
    window.update();
  }
  return 0;
}
